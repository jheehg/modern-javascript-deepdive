// 자바스크립트의 객체는 다른 객체지향언어와 다르게 클래스 없이 객체 생성이 가능하며,
// 동적으로 프로퍼티 삭제, 생성이 가능하다.
// 이 동적으로 가능한 기능으로 인해 성능이 비효율적으로 작용할 수 있는 단점을 보완하기 위해
// 프로퍼티 접근 시, 프로퍼티를 인덱스로 한 해시테이블로 객체를 구현하며,
// 히든클래스라는 방식을 사용해 어느정도 성능을 보장한다.

// 객체의 경우,
// 객체를 할당한 변수가 기억하는 메모리주소를 통해 메모리 공간에 접근하면 참조값에 접근이 가능함.
// obj변수가 저장된 메모리에 접근 -> 원시값처럼 값 자체가 있는게 아니라 또 다른 메모리주소에 접근하게 됨.
var obj = { x: 1};

obj.y = 20;
// 프로퍼티 동적 할당해도 참조하는 메모리 값은 변하지 않음.
// 참조하는 메모리값이 가리키는 객체가 변하는 것임.
// 원시값은 재할당 시, 새로운 메모리를 참조하는 것에 비해 객체는 참조하는 메모리가 동일해서 변경이 가능하다고 말하는 것이다.

// 이렇게 변경이 가능한 이유는,
// 원시값과 다르게 객체는 정해진 메모리 크기를 가질 수 없고, 동적으로 추가 및 삭제가 되며 
// 프로퍼티 값으로 객체를 가질 수 있으므로
// 메모리를 효율적으로 사용하기 위해 한 메모리가 참조하는 값이 변경이 가능하도록 하는 것임.

// 이것에 의한 단점은, 여러 식별자(변수)가 같은 메모리를 참조해서 변경할수 있다는 것.

// 얕은복사, 깊은복사
// 얕은 복사 : 프로퍼티를 객체로 가지는 객체 (중첩객체)를 복사할 떄 객체 한단계만 복사하는 것.
// 깊은 복사 : 프로퍼티를 객체로 가지는 객체 (중첩객체)를 복사할 떄 중첩된 객체까지 모두 복사하는 것.
const o = { x: {y: 10}};
const copyObj = {...o};
console.log(o === copyObj); // 한단계 얕은 복사가 됐으므로(서로 다른 메모리를 참조하므로) false
console.log(o.x === copyObj.x); // 복사한 객체의 프로퍼티가 가리키는 메모리는 동일함.
console.log(o.x.y === copyObj.x.y); // 이거는 원시값을 비교하게 되므로 10이라는 같은 값을 비교해서 true이지 않을까.


// 아래처럼 부른 경우도 있음. 할당 후 서로 간섭을 하는 유무로 이렇게 부르게 된거 아닐까 싶음.
// 원시값 할당 => 깊은 복사
// 객체 할당 => 얕은 복사





